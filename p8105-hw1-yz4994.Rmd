---
title: "p8105-hw1-yz4994"
author: "YiwenZhang"
date: "2025-09-19"
output: html_document
---

# Problem 1

I start by loading the `moderndive` package and accessing the `early_january_weather` dataset.I have installed the package "moderndive" in the console.

Now I load required libraries
```{R}
library(moderndive)
library(tidyverse)
```
Now I load the dataset we need
```{R}
data("early_january_weather")
nrow(early_january_weather)
ncol(early_january_weather)
mean(early_january_weather$temp, na.rm = TRUE)
glimpse(early_january_weather)
```
According to the help file of the dataset, I get the following information:

1.Description:Hourly meteorological data for LGA, JFK and EWR for the month of January 2013.The dataset is a data frame of 358rows representing hourly measurements and 15 variables (358rows and 15 columns).

2.The mean temperature is 39.58212 F.

3.The variables in this dataset, including names / values of important variables:

origin: Weather station, e.g.EWR

year:year of recording time, e.g.2013

month: month of recording time, e.g.1

day: day of recording time, e.g.1

hour: hour of recording time, e.g.3

temp: temperature in F, e.g.39.02

dewp: dewpoint in F, e.g.26.96

humid: relative humidity, e.g.59.37

wind_dir: winf direction (in degree), e.g.270

wind_speed: wind speed, e.g.10.35702

wind_gust: wind gust speed (in mph), e.g.20

precip: precipitation, in inches, e.g.0

pressure: sea level pressure in millibars, e.g.1012.3

visib: visibility in miles, e.g.10

time_hour: date and hour of the recording as a POSIXct date, e.g.2013-01-01 01:00:00

```{R}
ggplot(early_january_weather, aes(x = time_hour, y = temp, color = humid)) +
  geom_point(alpha = 0.6) +
  labs(
    title = "Temperature vs Time in Early January 2013",
    x = "Time (hourly)",
    y = "Temperature (°F)",
    color = "Humidity"
  ) +
  theme_minimal()
```

## Export the plot
```{R}
ggsave("scatter_temp_time.png", width = 7, height = 4)
```

# Problem 2

This problem emphasizes variable types and coercion in R.

## 1.Create the data frame
```{R}
set.seed(123)   # for reproducibility

df2 <- tibble(
  sample_norm = rnorm(10),                       # numeric
  logical_vec = rnorm(10) > 0,                   # logical
  char_vec = sample(letters, 10, replace = TRUE),# character
  factor_vec = factor(sample(c("low", "med", "high"), 10, replace = TRUE))
)

df2
```
## 2. Take the mean of each variable
```{R}
mean(df2$sample_norm)   # works: numeric
mean(df2$logical_vec)   # works: TRUE = 1, FALSE = 0
mean(df2$char_vec)      # fails: characters cannot be averaged
mean(df2$factor_vec)    # fails: factors not numeric by default
```
## 3. Explanation
```{markdown}
- **Numeric variable**: Taking the mean works as expected.  
- **Logical variable**: Taking the mean works; R treats `TRUE = 1` and `FALSE = 0`. The mean is the proportion of TRUE values.  
- **Character variable**: Taking the mean fails because characters cannot be coerced to numbers automatically.  
- **Factor variable**: Taking the mean fails because factors are categorical labels, not numeric.  
```
## 4. Using `as.numeric`
```{R,echo=TRUE, results='hide'}
as.numeric(df2$logical_vec)   # converts TRUE/FALSE → 1/0
as.numeric(df2$char_vec)      # returns NA with warning (cannot convert letters to numbers)
as.numeric(df2$factor_vec)    # converts factor levels → underlying integer codes (1, 2, 3)
```
## Explanation
```{markdown}
- Converting **logical** to numeric turns TRUE/FALSE into 1/0, which explains why taking the mean of a logical vector gives the proportion of TRUEs.  
- Converting **character** to numeric produces NAs (with a warning), since characters like "a", "b", "c" have no numeric representation.  
- Converting **factor** to numeric produces the underlying integer codes of the factor levels, not the labels. This explains why you can’t take a mean of factors directly — the numbers would represent codes, not meaningful values.  
```