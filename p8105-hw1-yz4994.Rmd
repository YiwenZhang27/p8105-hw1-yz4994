---
title: "p8105-hw1-yz4994"
author: "YiwenZhang"
date: "2025-09-19"
output:
  html_document
---

# Problem 1

I start by loading the `moderndive` package and accessing the `early_january_weather` dataset.I have installed the package "moderndive" in the console.

Now I load required libraries

```{R}
library(moderndive)
library(tidyverse)
```

Now I load the dataset we need

```{R}
data("early_january_weather")
nrow(early_january_weather)
ncol(early_january_weather)
mean(early_january_weather$temp, na.rm = TRUE)
glimpse(early_january_weather)
```

According to the help file of the dataset, I get the following information:

1.Description:Hourly meteorological data for LGA, JFK and EWR for the month of January 2013.The dataset is a data frame of **`r nrow(early_january_weather)`** rows representing hourly measurements and **`r ncol(early_january_weather)`** variables (**`r nrow(early_january_weather)`** rows and **`r ncol(early_january_weather)`** columns).

2.The mean temperature is **`r mean(early_january_weather$temp)`** F.

3.The variables in this dataset, including names / values of important variables:

The variables are: `r paste(names(early_january_weather), collapse = ", ")`
The dataset `early_january_weather` from the `moderndive` package has character variable **origin**, integer variables **year, month, day, hour**, double class variables **temp, dewp, humid, wind_dir, wind_speed, wind_gust, precip, precip, visib**, and date and time variable **time_hour**.

```{R}
ggplot(early_january_weather, aes(x = time_hour, y = temp, color = humid)) +
  geom_point(alpha = 0.6) +
  labs(
    title = "Temperature vs Time in Early January 2013",
    x = "Time (hourly)",
    y = "Temperature (°F)",
    color = "Humidity"
  ) +
  theme_minimal()
```

## Patterns
### 1.Daily fluctuations
Temperature follows a repeating cycle: it tends to dip during the early hours and rise during the daytime.

### 2.Cold spell early in January
From January 1st through about January 5th–6th, temperatures are mostly below 35°F.

### 3.Relationship with humidity
Darker points (higher humidity) cluster around lower temperatures.
Lighter points (lower humidity) are more common when the temperature is relatively higher.

### 4.Total Patterns
The scatterplot shows daily cycles in temperature, with colder early mornings and warmer afternoons. A cold spell appears in early January, followed by a warming trend after January 10th, peaking above 50°F by mid-January. Higher humidity is generally observed when temperatures are low, while lower humidity coincides with warmer periods. This indicates an inverse relationship between temperature and humidity.

## Export the plot

```{R}
ggsave("scatter_temp_time.png", width = 7, height = 4)
```

# Problem 2

This problem emphasizes variable types and coercion in R.

## 1.Create the data frame

```{R}
set.seed(123)   # for reproducibility

df2 <- tibble(
  sample_norm = rnorm(10),                       # numeric
  logical_vec = rnorm(10) > 0,                   # logical
  char_vec = sample(letters, 10, replace = TRUE),# character
  factor_vec = factor(sample(c("low", "med", "high"), 10, replace = TRUE))
)

df2
```

## 2. Take the mean of each variable

```{R}
mean(pull(df2,sample_norm))   # works: numeric
mean(pull(df2,logical_vec))  # works: TRUE = 1, FALSE = 0
mean(pull(df2,char_vec))      # fails: characters cannot be averaged
mean(pull(df2,factor_vec))    # fails: factors not numeric by default
```

## 3. Explanation

```{markdown}
- **Numeric variable**: Taking the mean works as expected.  
- **Logical variable**: Taking the mean works; R treats `TRUE = 1` and `FALSE = 0`. The mean is the proportion of TRUE values.  
- **Character variable**: Taking the mean fails because characters cannot be coerced to numbers automatically.  
- **Factor variable**: Taking the mean fails because factors are categorical labels, not numeric.  
```

## 4. Using `as.numeric`

```{R,echo=TRUE, results='hide'}
as.numeric(pull(df2,logical_vec))   # converts TRUE/FALSE → 1/0
as.numeric(pull(df2,char_vec))      # returns NA with warning (cannot convert letters to numbers)
as.numeric(pull(df2,factor_vec))    # converts factor levels → underlying integer codes (1, 2, 3)
```

## Explanation

```{markdown}
- Converting **logical** to numeric turns TRUE/FALSE into 1/0, which explains why taking the mean of a logical vector gives the proportion of TRUEs.  
- Converting **character** to numeric produces NAs (with a warning), since characters like "a", "b", "c" have no numeric representation.  
- Converting **factor** to numeric produces the underlying integer codes of the factor levels, not the labels. This explains why I can’t take a mean of factors directly — the numbers would represent codes, not meaningful values.  
```
